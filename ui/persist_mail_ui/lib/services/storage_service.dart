import 'package:hive_flutter/hive_flutter.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import '../config/app_config.dart';
import '../models/email_model.dart';
import '../models/domain_model.dart';
import '../models/user_preferences.dart';
import '../models/mailbox_history.dart';

class StorageService {
  static const FlutterSecureStorage _secureStorage = FlutterSecureStorage();

  static Box<EmailModel>? _emailBox;
  static Box<DomainModel>? _domainBox;
  static Box<UserPreferences>? _preferencesBox;
  static Box<MailboxHistory>? _mailboxHistoryBox;

  // Initialize Hive and register adapters
  static Future<void> init() async {
    await Hive.initFlutter();

    // Register adapters (will be generated by build_runner)
    // TODO: Uncomment after running build_runner
    // Hive.registerAdapter(EmailModelAdapter());
    // Hive.registerAdapter(DomainModelAdapter());
    // Hive.registerAdapter(UserPreferencesAdapter());
    // Hive.registerAdapter(MailboxHistoryAdapter());

    // Open boxes with dynamic types for now
    _emailBox = await Hive.openBox<EmailModel>(AppConfig.emailBoxName);
    _domainBox = await Hive.openBox<DomainModel>(AppConfig.domainsBoxName);
    _preferencesBox = await Hive.openBox<UserPreferences>(
      AppConfig.preferencesBoxName,
    );
    _mailboxHistoryBox = await Hive.openBox<MailboxHistory>(
      AppConfig.mailboxHistoryBoxName,
    );
  }

  // Email Storage
  static Future<void> saveEmail(EmailModel email) async {
    await _emailBox?.put(email.id, email);
  }

  static Future<void> saveEmailsForMailbox(
    List<EmailModel> emails,
    String mailbox,
  ) async {
    // Clear existing emails for this mailbox first
    await clearEmailsForMailbox(mailbox);

    final Map<String, EmailModel> emailMap = {
      for (var email in emails) email.id: email,
    };
    await _emailBox?.putAll(emailMap);
  }

  static Future<void> saveEmails(List<EmailModel> emails) async {
    final Map<String, EmailModel> emailMap = {
      for (var email in emails) email.id: email,
    };
    await _emailBox?.putAll(emailMap);
  }

  static List<EmailModel> getCachedEmails() {
    return _emailBox?.values.toList() ?? [];
  }

  static List<EmailModel> getCachedEmailsForMailbox(String mailbox) {
    final allEmails = _emailBox?.values.toList() ?? [];
    return allEmails.where((email) => email.to == mailbox).toList();
  }

  static EmailModel? getEmailById(String id) {
    return _emailBox?.get(id);
  }

  static Future<void> clearEmailsForMailbox(String mailbox) async {
    final emailsToRemove = <String>[];
    final allEmails = _emailBox?.values.toList() ?? [];

    for (final email in allEmails) {
      if (email.to == mailbox) {
        emailsToRemove.add(email.id);
      }
    }

    for (final emailId in emailsToRemove) {
      await _emailBox?.delete(emailId);
    }
  }

  static Future<void> clearEmails() async {
    await _emailBox?.clear();
  }

  static Future<void> removeEmail(String emailId) async {
    await _emailBox?.delete(emailId);
  }

  // Domain Storage
  static Future<void> saveDomains(List<DomainModel> domains) async {
    final Map<String, DomainModel> domainMap = {
      for (var domain in domains) domain.domain: domain,
    };
    await _domainBox?.putAll(domainMap);
  }

  static List<DomainModel> getCachedDomains() {
    return _domainBox?.values.toList() ?? [];
  }

  static Future<void> clearDomains() async {
    await _domainBox?.clear();
  }

  // User Preferences
  static Future<void> savePreferences(UserPreferences preferences) async {
    await _preferencesBox?.put('user_prefs', preferences);
  }

  static UserPreferences getUserPreferences() {
    return _preferencesBox?.get('user_prefs') ??
        UserPreferences.defaultPreferences();
  }

  static Future<void> clearPreferences() async {
    await _preferencesBox?.clear();
  }

  // Mailbox History Storage
  static Future<void> saveMailboxHistory(MailboxHistory history) async {
    await _mailboxHistoryBox?.put(history.email, history);
  }

  static Future<void> addMailboxToHistory(String email, String domain) async {
    // Check if already exists and update lastUsed, or create new entry
    MailboxHistory? existing = _mailboxHistoryBox?.get(email);
    if (existing != null) {
      final updated = existing.copyWith(lastUsed: DateTime.now());
      await _mailboxHistoryBox?.put(email, updated);
    } else {
      final newHistory = MailboxHistory.fromEmailAndDomain(email, domain);
      await _mailboxHistoryBox?.put(email, newHistory);
    }
  }

  static List<MailboxHistory> getCachedMailboxHistories() {
    final histories = _mailboxHistoryBox?.values.toList() ?? [];
    // Sort by lastUsed (most recent first) and limit to 12
    histories.sort((a, b) => b.lastUsed.compareTo(a.lastUsed));
    return histories.take(12).toList();
  }

  static MailboxHistory? getMailboxHistoryByEmail(String email) {
    return _mailboxHistoryBox?.get(email);
  }

  static Future<void> deleteMailboxHistory(String email) async {
    // Delete the mailbox from history
    await _mailboxHistoryBox?.delete(email);

    // Delete all emails associated with this mailbox
    await clearEmailsForMailbox(email);
  }

  static Future<void> clearMailboxHistories() async {
    await _mailboxHistoryBox?.clear();
  }

  // Secure Storage for sensitive data
  static Future<void> saveSecureData(String key, String value) async {
    await _secureStorage.write(key: key, value: value);
  }

  static Future<String?> getSecureData(String key) async {
    return await _secureStorage.read(key: key);
  }

  static Future<void> deleteSecureData(String key) async {
    await _secureStorage.delete(key: key);
  }

  static Future<void> clearAllSecureData() async {
    await _secureStorage.deleteAll();
  }

  // Cleanup
  static Future<void> dispose() async {
    await _emailBox?.close();
    await _domainBox?.close();
    await _preferencesBox?.close();
    await _mailboxHistoryBox?.close();
  }
}
